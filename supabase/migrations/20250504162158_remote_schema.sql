create extension if not exists "wrappers" with schema "extensions";


create table "public"."chapters" (
    "id" uuid not null default gen_random_uuid(),
    "title" character varying(150) not null,
    "course_id" uuid not null,
    "sub_title" character varying(100),
    "description" character varying(300),
    "serial_number" integer generated by default as identity not null,
    "created_at" timestamp without time zone not null default now(),
    "updated_at" timestamp without time zone not null default now()
);


alter table "public"."chapters" enable row level security;

create table "public"."courses" (
    "id" uuid not null default gen_random_uuid(),
    "title" character varying(150) not null,
    "short_description" character varying(500),
    "description" character varying(10000),
    "thumbnail" text,
    "is_published" boolean,
    "published_at" timestamp without time zone,
    "created_at" timestamp without time zone not null default now(),
    "updated_at" timestamp without time zone not null default now(),
    "profile_id" uuid not null,
    "course_language" integer,
    "language_taught" integer,
    "description_html" text,
    "support_link" text,
    "description_json" text,
    "course_language_dialect" bigint,
    "language_taught_dialect" bigint,
    "is_federated" boolean default false
);


alter table "public"."courses" enable row level security;

create table "public"."dialects" (
    "id" bigint generated by default as identity not null,
    "language_id" bigint not null,
    "name_en" text not null,
    "name_native" text,
    "description" text,
    "region" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."dialects" enable row level security;

create table "public"."enrollments" (
    "id" uuid not null default gen_random_uuid(),
    "profile_id" uuid not null,
    "course_id" uuid not null,
    "created_at" timestamp without time zone not null,
    "updated_at" timestamp without time zone not null
);


alter table "public"."enrollments" enable row level security;

create table "public"."federation_instances" (
    "id" uuid not null default uuid_generate_v4(),
    "name" text not null,
    "url" text not null,
    "is_active" boolean default true,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
);


alter table "public"."federation_instances" enable row level security;

create table "public"."flashcards" (
    "id" uuid not null default uuid_generate_v4(),
    "chapter_id" uuid,
    "front_content" text not null,
    "back_content" text not null,
    "front_content_html" text,
    "back_content_html" text,
    "hint" text,
    "difficulty_level" integer default 1,
    "serial_number" integer not null,
    "created_at" timestamp with time zone default CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone default CURRENT_TIMESTAMP,
    "section_id" uuid
);


alter table "public"."flashcards" enable row level security;

create table "public"."languages" (
    "id" bigint generated by default as identity not null,
    "code" text not null,
    "name_en" text not null,
    "name_native" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "name_jpn" text
);


alter table "public"."languages" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "name" character varying(50) not null,
    "bio" character varying(500),
    "subtitle" character varying(45),
    "avatar_url" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "email" text,
    "is_admin" boolean default false
);


alter table "public"."profiles" enable row level security;

create table "public"."reading" (
    "id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "text" text not null default ''::text,
    "translation" text not null default ''::text,
    "serial_number" integer not null,
    "chapter_id" uuid not null
);


alter table "public"."reading" enable row level security;

create table "public"."sections" (
    "id" uuid not null default gen_random_uuid(),
    "title" character varying(150) not null,
    "chapter_id" uuid not null,
    "content_html" text,
    "content_json" json,
    "serial_number" integer not null,
    "created_at" timestamp without time zone not null,
    "updated_at" timestamp without time zone not null,
    "sub_title" character varying(300)
);


alter table "public"."sections" enable row level security;

create table "public"."user_flashcard_progress" (
    "id" uuid not null default uuid_generate_v4(),
    "profile_id" uuid,
    "flashcard_id" uuid,
    "ease_factor" double precision default 2.5,
    "interval" integer default 1,
    "due_date" timestamp with time zone default CURRENT_TIMESTAMP,
    "review_count" integer default 0,
    "correct_count" integer default 0,
    "incorrect_count" integer default 0,
    "last_reviewed" timestamp with time zone,
    "created_at" timestamp with time zone default CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone default CURRENT_TIMESTAMP
);


alter table "public"."user_flashcard_progress" enable row level security;

create table "public"."user_section_progress" (
    "id" uuid not null default gen_random_uuid(),
    "profile_id" uuid not null,
    "section_id" uuid not null,
    "completion_percentage" integer default 0,
    "last_viewed" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."user_section_progress" enable row level security;

CREATE UNIQUE INDEX chapters_pkey ON public.chapters USING btree (id);

CREATE UNIQUE INDEX courses_pkey ON public.courses USING btree (id);

CREATE UNIQUE INDEX dialects_pkey ON public.dialects USING btree (id);

CREATE UNIQUE INDEX enrollments_pkey ON public.enrollments USING btree (id);

CREATE UNIQUE INDEX federation_instances_pkey ON public.federation_instances USING btree (id);

CREATE UNIQUE INDEX flashcards_pkey ON public.flashcards USING btree (id);

CREATE INDEX idx_courses_course_language_dialect ON public.courses USING btree (course_language_dialect);

CREATE INDEX idx_courses_language_taught_dialect ON public.courses USING btree (language_taught_dialect);

CREATE INDEX idx_dialects_language_id ON public.dialects USING btree (language_id);

CREATE INDEX idx_flashcards_section_id ON public.flashcards USING btree (section_id);

CREATE INDEX idx_languages_code ON public.languages USING btree (code);

CREATE INDEX idx_user_section_progress_profile_id ON public.user_section_progress USING btree (profile_id);

CREATE INDEX idx_user_section_progress_section_id ON public.user_section_progress USING btree (section_id);

CREATE UNIQUE INDEX languages_pkey ON public.languages USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX reading_pkey ON public.reading USING btree (id);

CREATE UNIQUE INDEX sections_pkey ON public.sections USING btree (id);

CREATE UNIQUE INDEX user_flashcard_progress_pkey ON public.user_flashcard_progress USING btree (id);

CREATE UNIQUE INDEX user_flashcard_progress_profile_id_flashcard_id_key ON public.user_flashcard_progress USING btree (profile_id, flashcard_id);

CREATE UNIQUE INDEX user_section_progress_pkey ON public.user_section_progress USING btree (id);

CREATE UNIQUE INDEX user_section_progress_profile_id_section_id_key ON public.user_section_progress USING btree (profile_id, section_id);

alter table "public"."chapters" add constraint "chapters_pkey" PRIMARY KEY using index "chapters_pkey";

alter table "public"."courses" add constraint "courses_pkey" PRIMARY KEY using index "courses_pkey";

alter table "public"."dialects" add constraint "dialects_pkey" PRIMARY KEY using index "dialects_pkey";

alter table "public"."enrollments" add constraint "enrollments_pkey" PRIMARY KEY using index "enrollments_pkey";

alter table "public"."federation_instances" add constraint "federation_instances_pkey" PRIMARY KEY using index "federation_instances_pkey";

alter table "public"."flashcards" add constraint "flashcards_pkey" PRIMARY KEY using index "flashcards_pkey";

alter table "public"."languages" add constraint "languages_pkey" PRIMARY KEY using index "languages_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."reading" add constraint "reading_pkey" PRIMARY KEY using index "reading_pkey";

alter table "public"."sections" add constraint "sections_pkey" PRIMARY KEY using index "sections_pkey";

alter table "public"."user_flashcard_progress" add constraint "user_flashcard_progress_pkey" PRIMARY KEY using index "user_flashcard_progress_pkey";

alter table "public"."user_section_progress" add constraint "user_section_progress_pkey" PRIMARY KEY using index "user_section_progress_pkey";

alter table "public"."chapters" add constraint "chapters_course_id_fkey" FOREIGN KEY (course_id) REFERENCES courses(id) ON DELETE CASCADE not valid;

alter table "public"."chapters" validate constraint "chapters_course_id_fkey";

alter table "public"."courses" add constraint "courses_course_language_dialect_fkey" FOREIGN KEY (course_language_dialect) REFERENCES dialects(id) ON DELETE SET NULL not valid;

alter table "public"."courses" validate constraint "courses_course_language_dialect_fkey";

alter table "public"."courses" add constraint "courses_course_language_fkey" FOREIGN KEY (course_language) REFERENCES languages(id) ON DELETE CASCADE not valid;

alter table "public"."courses" validate constraint "courses_course_language_fkey";

alter table "public"."courses" add constraint "courses_description_html_check" CHECK ((length(description_html) <= 10000)) not valid;

alter table "public"."courses" validate constraint "courses_description_html_check";

alter table "public"."courses" add constraint "courses_language_taught_dialect_fkey" FOREIGN KEY (language_taught_dialect) REFERENCES dialects(id) ON DELETE SET NULL not valid;

alter table "public"."courses" validate constraint "courses_language_taught_dialect_fkey";

alter table "public"."courses" add constraint "courses_language_taught_fkey" FOREIGN KEY (language_taught) REFERENCES languages(id) ON DELETE CASCADE not valid;

alter table "public"."courses" validate constraint "courses_language_taught_fkey";

alter table "public"."courses" add constraint "courses_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."courses" validate constraint "courses_profile_id_fkey";

alter table "public"."dialects" add constraint "dialects_language_id_fkey" FOREIGN KEY (language_id) REFERENCES languages(id) ON DELETE CASCADE not valid;

alter table "public"."dialects" validate constraint "dialects_language_id_fkey";

alter table "public"."enrollments" add constraint "enrollments_course_id_fkey" FOREIGN KEY (course_id) REFERENCES courses(id) ON DELETE CASCADE not valid;

alter table "public"."enrollments" validate constraint "enrollments_course_id_fkey";

alter table "public"."enrollments" add constraint "enrollments_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."enrollments" validate constraint "enrollments_profile_id_fkey";

alter table "public"."flashcards" add constraint "flashcards_chapter_id_fkey" FOREIGN KEY (chapter_id) REFERENCES chapters(id) ON DELETE CASCADE not valid;

alter table "public"."flashcards" validate constraint "flashcards_chapter_id_fkey";

alter table "public"."flashcards" add constraint "flashcards_section_id_fkey" FOREIGN KEY (section_id) REFERENCES sections(id) ON DELETE CASCADE not valid;

alter table "public"."flashcards" validate constraint "flashcards_section_id_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."reading" add constraint "reading_chapter_id_fkey" FOREIGN KEY (chapter_id) REFERENCES chapters(id) not valid;

alter table "public"."reading" validate constraint "reading_chapter_id_fkey";

alter table "public"."sections" add constraint "sections_chapter_id_fkey" FOREIGN KEY (chapter_id) REFERENCES chapters(id) ON DELETE CASCADE not valid;

alter table "public"."sections" validate constraint "sections_chapter_id_fkey";

alter table "public"."user_flashcard_progress" add constraint "user_flashcard_progress_flashcard_id_fkey" FOREIGN KEY (flashcard_id) REFERENCES flashcards(id) ON DELETE CASCADE not valid;

alter table "public"."user_flashcard_progress" validate constraint "user_flashcard_progress_flashcard_id_fkey";

alter table "public"."user_flashcard_progress" add constraint "user_flashcard_progress_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_flashcard_progress" validate constraint "user_flashcard_progress_profile_id_fkey";

alter table "public"."user_flashcard_progress" add constraint "user_flashcard_progress_profile_id_flashcard_id_key" UNIQUE using index "user_flashcard_progress_profile_id_flashcard_id_key";

alter table "public"."user_section_progress" add constraint "user_section_progress_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_section_progress" validate constraint "user_section_progress_profile_id_fkey";

alter table "public"."user_section_progress" add constraint "user_section_progress_profile_id_section_id_key" UNIQUE using index "user_section_progress_profile_id_section_id_key";

alter table "public"."user_section_progress" add constraint "user_section_progress_section_id_fkey" FOREIGN KEY (section_id) REFERENCES sections(id) ON DELETE CASCADE not valid;

alter table "public"."user_section_progress" validate constraint "user_section_progress_section_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.calculate_quiz_score()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
    v_total_points numeric;
    v_earned_points numeric;
    v_passing_score integer;
begin
    -- Calculate total and earned points
    select 
        sum(q.points) as total_points,
        sum(ua.points_earned) as earned_points
    into v_total_points, v_earned_points
    from quiz_questions q
    left join user_answers ua on ua.question_id = q.id and ua.attempt_id = new.id
    where q.quiz_id = new.quiz_id;

    -- Calculate score as percentage
    new.score := (v_earned_points / v_total_points * 100)::numeric(5,2);

    -- Get passing score and determine if passed
    select passing_score into v_passing_score
    from quizzes
    where id = new.quiz_id;

    new.passed := new.score >= v_passing_score;

    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_course_completion_percentage(p_course_id uuid, p_user_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_section_count INTEGER;
  v_section_completed INTEGER;
  v_character_count INTEGER;
  v_character_completed INTEGER;
  v_total_count INTEGER;
  v_total_completed INTEGER;
  v_percentage INTEGER;
BEGIN
  -- Count sections in the course
  SELECT COUNT(*) INTO v_section_count
  FROM sections s
  JOIN chapters c ON s.chapter_id = c.id
  WHERE c.course_id = p_course_id;
  
  -- Count completed sections
  SELECT COUNT(*) INTO v_section_completed
  FROM user_section_progress usp
  JOIN sections s ON usp.section_id = s.id
  JOIN chapters c ON s.chapter_id = c.id
  WHERE 
    c.course_id = p_course_id AND
    usp.profile_id = p_user_id AND
    usp.completion_percentage >= 80;
    
  -- Count characters in the course
  SELECT COUNT(*) INTO v_character_count
  FROM characters ch
  JOIN character_sets cs ON ch.character_set_id = cs.id
  JOIN character_categories cc ON cs.category_id = cc.id
  WHERE cc.course_id = p_course_id;
  
  -- Count mastered characters
  SELECT COUNT(*) INTO v_character_completed
  FROM user_character_progress ucp
  JOIN characters ch ON ucp.character_id = ch.id
  JOIN character_sets cs ON ch.character_set_id = cs.id
  JOIN character_categories cc ON cs.category_id = cc.id
  WHERE 
    cc.course_id = p_course_id AND
    ucp.profile_id = p_user_id AND
    ucp.proficiency_level >= 4;
    
  -- Calculate overall percentage
  v_total_count := v_section_count + v_character_count;
  v_total_completed := v_section_completed + v_character_completed;
  
  IF v_total_count = 0 THEN
    RETURN 0;
  ELSE
    v_percentage := (v_total_completed * 100) / v_total_count;
    RETURN v_percentage;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_course_data_with_counts()
 RETURNS TABLE(id uuid, title text, short_description text, thumbnail text, language_taught text, course_language text, author_id uuid, author_name text, author_subtitle text, author_avatar_url text, enrolled_students integer, created_at timestamp without time zone)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY 
  SELECT 
    c.id::UUID,
    c.title::TEXT,
    c.short_description::TEXT,
    c.thumbnail::TEXT,
    lt.name_en::TEXT AS language_taught,
    cl.name_en::TEXT AS course_language,
    p.id::UUID AS author_id,
    p.name::TEXT AS author_name,
    p.subtitle::TEXT AS author_subtitle,
    p.avatar_url::TEXT AS author_avatar_url,
    get_enrollment_count(c.id) AS enrolled_students,
    c.created_at::TIMESTAMP
  FROM courses c
  LEFT JOIN languages lt ON c.language_taught = lt.id
  LEFT JOIN languages cl ON c.course_language = cl.id
  LEFT JOIN profiles p ON c.profile_id = p.id
  WHERE c.is_published = TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_due_character_reviews(p_profile_id uuid, p_limit integer DEFAULT 20)
 RETURNS TABLE(character_id uuid, "character" text, meaning text, pronunciation text, examples jsonb, difficulty_level integer, due_date timestamp with time zone, proficiency_level integer)
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT 
    c.id AS character_id,
    c."character",
    c.meaning,
    c.pronunciation,
    c.examples,
    c.difficulty_level,
    ucp.due_date,
    ucp.proficiency_level
  FROM user_character_progress ucp
  JOIN characters c ON ucp.character_id = c.id
  WHERE 
    ucp.profile_id = p_profile_id AND
    ucp.due_date <= NOW()
  ORDER BY ucp.due_date ASC
  LIMIT p_limit;
$function$
;

CREATE OR REPLACE FUNCTION public.get_due_flashcards(p_profile_id uuid, p_course_id uuid, p_limit integer DEFAULT 10)
 RETURNS SETOF flashcards
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT f.*
  FROM user_flashcard_progress ufp
  JOIN flashcards f ON ufp.flashcard_id = f.id
  LEFT JOIN sections s ON f.section_id = s.id
  LEFT JOIN chapters c ON s.chapter_id = c.id
  LEFT JOIN characters ch ON f.character_id = ch.id
  LEFT JOIN character_sets cs ON ch.character_set_id = cs.id
  LEFT JOIN character_categories cc ON cs.category_id = cc.id
  WHERE 
    ufp.profile_id = p_profile_id AND
    ufp.due_date <= NOW() AND
    (
      (c.course_id = p_course_id) OR
      (cc.course_id = p_course_id)
    )
  ORDER BY ufp.due_date ASC
  LIMIT p_limit;
$function$
;

CREATE OR REPLACE FUNCTION public.get_enrollment_count(course_uuid uuid)
 RETURNS integer
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT COUNT(*) FROM enrollments WHERE course_id = course_uuid;
$function$
;

CREATE OR REPLACE FUNCTION public.get_full_course(p_course_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return (
    select json_build_object(
      'id', c.id,
      'title', c.title,
      'short_description', c.short_description,
      'description', c.description,
      'thumbnail_url', c.thumbnail_url,
      'course_language', c.course_language,
      'language_taught', c.language_taught,
      'is_published', c.is_published,
      'author', json_build_object(
        'id', p.id,
        'name', p.name,
        'subtitle', p.subtitle,
        'avatar_url', p.avatar_url
      ),
      'chapters', (
        select json_agg(
          json_build_object(
            'id', ch.id,
            'title', ch.title,
            'subtitle', ch.subtitle,
            'serial_number', ch.serial_number,
            'sections', (
              select json_agg(
                json_build_object(
                  'id', s.id,
                  'title', s.title,
                  'subtitle', s.subtitle,
                  'content_html', s.content_html,
                  'content_json', s.content_json,
                  'serial_number', s.serial_number
                ) order by s.serial_number
              )
              from public.sections s
              where s.chapter_id = ch.id
            )
          ) order by ch.serial_number
        )
        from public.chapters ch
        where ch.course_id = c.id
      )
    )
    from public.courses c
    join public.profiles p on c.author_id = p.id
    where c.id = p_course_id
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_home_page_courses()
 RETURNS TABLE(id uuid, title text, short_description text, thumbnail text, language_taught text, course_language text, author_id uuid, author_name text, author_subtitle text, author_avatar_url text, enrolled_students integer, created_at timestamp without time zone, category text)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    c.id,
    c.title,
    c.short_description,
    c.thumbnail,
    c.language_taught,
    c.course_language,
    c.author_id,
    c.author_name,
    c.author_subtitle,
    c.author_avatar_url,
    c.enrolled_students,
    c.created_at,
    'popular' AS category
  FROM get_course_data_with_counts() c
  ORDER BY c.enrolled_students DESC
  LIMIT 8;

  RETURN QUERY
  SELECT 
    c.id,
    c.title,
    c.short_description,
    c.thumbnail,
    c.language_taught,
    c.course_language,
    c.author_id,
    c.author_name,
    c.author_subtitle,
    c.author_avatar_url,
    c.enrolled_students,  -- Fix: Use existing enrolled_students count
    c.created_at,
    'trending' AS category
  FROM get_course_data_with_counts() c
  WHERE c.created_at >= NOW() - INTERVAL '7 days'
  ORDER BY c.enrolled_students DESC
  LIMIT 8;

  RETURN QUERY
  SELECT 
    c.id,
    c.title,
    c.short_description,
    c.thumbnail,
    c.language_taught,
    c.course_language,
    c.author_id,
    c.author_name,
    c.author_subtitle,
    c.author_avatar_url,
    c.enrolled_students,
    c.created_at,
    'recent' AS category
  FROM get_course_data_with_counts() c
  ORDER BY c.created_at DESC
  LIMIT 8;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_learning_courses(input_profile_id uuid)
 RETURNS TABLE(id uuid, title text, short_description text, thumbnail text, language_taught text, course_language text, author_id uuid, author_name text, author_subtitle text, author_avatar_url text, enrolled_students integer, enrolled_at timestamp without time zone)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    c.id,
    c.title::TEXT,
    c.short_description::TEXT,
    c.thumbnail::TEXT,
    lt.name_en::TEXT AS language_taught,
    cl.name_en::TEXT AS course_language,
    p.id AS author_id,
    p.name::TEXT AS author_name,
    p.subtitle::TEXT AS author_subtitle,
    p.avatar_url::TEXT AS author_avatar_url,
    get_enrollment_count(c.id) AS enrolled_students,
    e.created_at AS enrolled_at
  FROM enrollments e
  INNER JOIN courses c ON e.course_id = c.id
  LEFT JOIN languages lt ON c.language_taught = lt.id
  LEFT JOIN languages cl ON c.course_language = cl.id
  LEFT JOIN profiles p ON c.profile_id = p.id
  WHERE e.profile_id = input_profile_id
  ORDER BY e.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_next_flashcard_serial(chapter_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  next_serial INTEGER;
BEGIN
  SELECT COALESCE(MAX(serial_number) + 1, 1)
  INTO next_serial
  FROM flashcards
  WHERE flashcards.chapter_id = $1;
  
  RETURN next_serial;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_sorted_courses()
 RETURNS TABLE(id uuid, title text, short_description text, thumbnail text, language_taught text, course_language text, author_id uuid, author_name text, author_subtitle text, author_avatar_url text, enrolled_students integer, created_at timestamp without time zone, category text)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  -- ✅ Popular Courses (sorted by total enrollments)
  RETURN QUERY
  SELECT *, 'popular' AS category
  FROM get_course_data_with_counts()
  ORDER BY enrolled_students DESC
  LIMIT 8;

  -- ✅ Trending Courses (sorted by enrollments in last 7 days)
  RETURN QUERY
  SELECT *, 'trending' AS category
  FROM get_course_data_with_counts()
  WHERE created_at >= NOW() - INTERVAL '7 days'
  ORDER BY enrolled_students DESC
  LIMIT 8;

  -- ✅ Recent Courses (sorted by created_at)
  RETURN QUERY
  SELECT *, 'recent' AS category
  FROM get_course_data_with_counts()
  ORDER BY created_at DESC
  LIMIT 8;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_teach_courses(input_profile_id uuid)
 RETURNS TABLE(id uuid, title text, short_description text, thumbnail text, language_taught text, course_language text, author_id uuid, author_name text, author_subtitle text, author_avatar_url text, enrolled_students integer, is_published boolean, created_at timestamp without time zone, category text)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    c.id,
    c.title::TEXT,
    c.short_description::TEXT,
    c.thumbnail::TEXT,
    lt.name_en::TEXT AS language_taught,
    cl.name_en::TEXT AS course_language,
    p.id AS author_id,
    p.name::TEXT AS author_name,
    p.subtitle::TEXT AS author_subtitle,
    p.avatar_url::TEXT AS author_avatar_url,
    get_enrollment_count(c.id) AS enrolled_students,
    c.is_published,
    c.created_at,
    'published' AS category
  FROM courses c
  LEFT JOIN languages lt ON c.language_taught = lt.id
  LEFT JOIN languages cl ON c.course_language = cl.id
  LEFT JOIN profiles p ON c.profile_id = p.id
  WHERE c.profile_id = input_profile_id AND c.is_published = TRUE
  ORDER BY c.created_at DESC;

  RETURN QUERY
  SELECT 
    c.id,
    c.title::TEXT,
    c.short_description::TEXT,
    c.thumbnail::TEXT,
    lt.name_en::TEXT AS language_taught,
    cl.name_en::TEXT AS course_language,
    p.id AS author_id,
    p.name::TEXT AS author_name,
    p.subtitle::TEXT AS author_subtitle,
    p.avatar_url::TEXT AS author_avatar_url,
    get_enrollment_count(c.id) AS enrolled_students,
    c.is_published,
    c.created_at,
    'draft' AS category
  FROM courses c
  LEFT JOIN languages lt ON c.language_taught = lt.id
  LEFT JOIN languages cl ON c.course_language = cl.id
  LEFT JOIN profiles p ON c.profile_id = p.id
  WHERE c.profile_id = input_profile_id AND c.is_published = FALSE
  ORDER BY c.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.profiles (id, name, email)
  VALUES (
    NEW.id, 
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email), -- Extract name from metadata or use email as fallback
    NEW.email
  );
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.import_language(p_code text, p_name_en text, p_name_native text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
begin
    insert into public.languages (code, name_en, name_native)
    values (lower(trim(p_code)), trim(p_name_en), trim(p_name_native))
    on conflict (code) do update set
        name_en = trim(excluded.name_en),
        name_native = trim(excluded.name_native),
        updated_at = now();
end;
$function$
;

CREATE OR REPLACE FUNCTION public.reorder_chapter_vocabulary(p_chapter_id uuid, p_vocabulary_orders jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
declare
    v_record record;
begin
    for v_record in 
        select * from jsonb_each(p_vocabulary_orders)
    loop
        update chapter_vocabulary
        set serial_number = (v_record.value)::integer
        where id = (v_record.key)::uuid
        and chapter_id = p_chapter_id;
    end loop;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.reorder_chapters(course_id uuid, chapter_ids uuid[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  chapter_id uuid;
  i integer;
BEGIN
  i := 1;
  FOREACH chapter_id IN ARRAY chapter_ids
  LOOP
    UPDATE chapters
    SET serial_number = i
    WHERE id = chapter_id AND course_id = $1;
    i := i + 1;
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reorder_flashcards(chapter_id uuid, flashcard_ids uuid[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  i INTEGER;
  fid UUID;
BEGIN
  FOR i IN 1..array_length(flashcard_ids, 1) LOOP
    fid := flashcard_ids[i];
    UPDATE flashcards
    SET serial_number = i
    WHERE id = fid AND chapter_id = $1;
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reorder_sections(chapter_id uuid, section_ids uuid[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  section_id uuid;
  i integer;
BEGIN
  i := 1;
  FOREACH section_id IN ARRAY section_ids
  LOOP
    UPDATE sections
    SET serial_number = i
    WHERE id = section_id AND chapter_id = $1;
    i := i + 1;
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_chapter_serial()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.serial_number IS NULL THEN
    NEW.serial_number := get_next_chapter_serial(NEW.course_id);
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_chapter_serial_number()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.serial_number IS NULL THEN
    NEW.serial_number := (
      SELECT COALESCE(MAX(serial_number), 0) + 1
      FROM public.chapters
      WHERE course_id = NEW.course_id
    );
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_section_serial()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.serial_number IS NULL THEN
    NEW.serial_number := get_next_section_serial(NEW.chapter_id);
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_section_serial_number()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.serial_number IS NULL THEN
    NEW.serial_number := (
      SELECT COALESCE(MAX(serial_number), 0) + 1
      FROM public.sections
      WHERE chapter_id = NEW.chapter_id
    );
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_vocabulary_serial_number()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    if new.serial_number is null then
        select coalesce(max(serial_number), 0) + 1
        into new.serial_number
        from chapter_vocabulary
        where chapter_id = new.chapter_id;
    end if;
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_profile_email()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- For new users
  IF TG_OP = 'INSERT' THEN
    -- Create a profile with basic info
    INSERT INTO public.profiles (
      id, 
      name,
      email
    ) VALUES (
      NEW.id,
      NEW.email, -- Just use email as the name initially
      NEW.email
    );
  -- For updated users
  ELSIF TG_OP = 'UPDATE' THEN
    -- Update just the email
    UPDATE public.profiles 
    SET 
      email = NEW.email,
      updated_at = NOW()
    WHERE id = NEW.id;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_chapter_completion_stats()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    -- Update the chapter's completion statistics
    update chapters
    set 
        completion_count = (
            select count(*)
            from chapter_completions
            where chapter_id = new.chapter_id
            and is_completed = true
        ),
        average_time_spent = (
            select avg(time_spent_seconds)::numeric(10,2)
            from chapter_completions
            where chapter_id = new.chapter_id
            and is_completed = true
            and time_spent_seconds is not null
        )
    where id = new.chapter_id;
    
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_character_progress(p_profile_id uuid, p_character_id uuid, p_performance_rating integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Get or create progress record
  DECLARE
    v_progress user_character_progress;
    v_ease_factor FLOAT;
    v_interval INTEGER;
  BEGIN
    SELECT * INTO v_progress FROM user_character_progress
    WHERE profile_id = p_profile_id AND character_id = p_character_id;
    
    IF NOT FOUND THEN
      INSERT INTO user_character_progress (
        profile_id, character_id, proficiency_level, 
        times_reviewed, times_correct, times_incorrect
      )
      VALUES (
        p_profile_id, p_character_id, 0, 0, 0, 0
      )
      RETURNING * INTO v_progress;
    END IF;
    
    -- Update counters
    UPDATE user_character_progress SET
      times_reviewed = times_reviewed + 1,
      times_correct = CASE WHEN p_performance_rating >= 3 THEN times_correct + 1 ELSE times_correct END,
      times_incorrect = CASE WHEN p_performance_rating < 3 THEN times_incorrect + 1 ELSE times_incorrect END,
      proficiency_level = LEAST(5, CASE 
        WHEN p_performance_rating >= 4 THEN proficiency_level + 1
        WHEN p_performance_rating <= 2 THEN GREATEST(0, proficiency_level - 1)
        ELSE proficiency_level
      END),
      last_reviewed = NOW()
    WHERE id = v_progress.id;
    
    -- Calculate new interval using SM-2 spaced repetition algorithm
    v_ease_factor := GREATEST(1.3, 2.5 + (0.1 - (5 - p_performance_rating) * 0.08 - (5 - p_performance_rating) * 0.02));
    
    IF p_performance_rating < 3 THEN
      -- If rating is less than 3, reset interval to 1 day
      v_interval := 1;
    ELSE
      -- Calculate new interval
      IF v_progress.times_reviewed <= 1 THEN
        v_interval := 1;
      ELSIF v_progress.times_reviewed = 2 THEN
        v_interval := 6;
      ELSE
        v_interval := GREATEST(1, ROUND(v_progress.interval * v_ease_factor));
      END IF;
    END IF;
    
    -- Update interval and due date
    UPDATE user_character_progress SET
      interval = v_interval,
      due_date = NOW() + (v_interval * INTERVAL '1 day'),
      updated_at = NOW()
    WHERE id = v_progress.id;
  END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_course_enrollment_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    -- Update the course's enrollment count
    update courses
    set total_enrollments = (
        select count(*)
        from course_enrollments
        where course_id = new.course_id
    )
    where id = new.course_id;
    
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_course_rating_stats()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    -- Update the course's rating statistics
    update courses
    set 
        average_rating = (
            select round(avg(rating)::numeric, 2)
            from course_ratings
            where course_id = new.course_id
        ),
        total_ratings = (
            select count(*)
            from course_ratings
            where course_id = new.course_id
        )
    where id = new.course_id;
    
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    new.updated_at = now();
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_chapter_completion()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
    v_course_id uuid;
    v_is_enrolled boolean;
begin
    -- Get the course ID for this chapter
    select course_id into v_course_id
    from chapters
    where id = new.chapter_id;

    -- Check if the user is enrolled in the course
    select exists(
        select 1
        from course_enrollments
        where course_id = v_course_id
        and user_id = new.user_id
    ) into v_is_enrolled;

    if not v_is_enrolled then
        raise exception 'User must be enrolled in the course to mark chapters as complete';
    end if;

    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_quiz_attempt()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
    v_max_attempts integer;
    v_attempt_count integer;
begin
    -- Get max attempts for this quiz
    select max_attempts into v_max_attempts
    from quizzes
    where id = new.quiz_id;

    -- If max_attempts is set, check the count
    if v_max_attempts is not null then
        select count(*) into v_attempt_count
        from quiz_attempts
        where quiz_id = new.quiz_id
        and user_id = new.user_id;

        if v_attempt_count >= v_max_attempts then
            raise exception 'Maximum number of attempts reached for this quiz';
        end if;
    end if;

    return new;
end;
$function$
;

grant delete on table "public"."chapters" to "anon";

grant insert on table "public"."chapters" to "anon";

grant references on table "public"."chapters" to "anon";

grant select on table "public"."chapters" to "anon";

grant trigger on table "public"."chapters" to "anon";

grant truncate on table "public"."chapters" to "anon";

grant update on table "public"."chapters" to "anon";

grant delete on table "public"."chapters" to "authenticated";

grant insert on table "public"."chapters" to "authenticated";

grant references on table "public"."chapters" to "authenticated";

grant select on table "public"."chapters" to "authenticated";

grant trigger on table "public"."chapters" to "authenticated";

grant truncate on table "public"."chapters" to "authenticated";

grant update on table "public"."chapters" to "authenticated";

grant delete on table "public"."chapters" to "service_role";

grant insert on table "public"."chapters" to "service_role";

grant references on table "public"."chapters" to "service_role";

grant select on table "public"."chapters" to "service_role";

grant trigger on table "public"."chapters" to "service_role";

grant truncate on table "public"."chapters" to "service_role";

grant update on table "public"."chapters" to "service_role";

grant delete on table "public"."courses" to "anon";

grant insert on table "public"."courses" to "anon";

grant references on table "public"."courses" to "anon";

grant select on table "public"."courses" to "anon";

grant trigger on table "public"."courses" to "anon";

grant truncate on table "public"."courses" to "anon";

grant update on table "public"."courses" to "anon";

grant delete on table "public"."courses" to "authenticated";

grant insert on table "public"."courses" to "authenticated";

grant references on table "public"."courses" to "authenticated";

grant select on table "public"."courses" to "authenticated";

grant trigger on table "public"."courses" to "authenticated";

grant truncate on table "public"."courses" to "authenticated";

grant update on table "public"."courses" to "authenticated";

grant delete on table "public"."courses" to "service_role";

grant insert on table "public"."courses" to "service_role";

grant references on table "public"."courses" to "service_role";

grant select on table "public"."courses" to "service_role";

grant trigger on table "public"."courses" to "service_role";

grant truncate on table "public"."courses" to "service_role";

grant update on table "public"."courses" to "service_role";

grant delete on table "public"."dialects" to "anon";

grant insert on table "public"."dialects" to "anon";

grant references on table "public"."dialects" to "anon";

grant select on table "public"."dialects" to "anon";

grant trigger on table "public"."dialects" to "anon";

grant truncate on table "public"."dialects" to "anon";

grant update on table "public"."dialects" to "anon";

grant delete on table "public"."dialects" to "authenticated";

grant insert on table "public"."dialects" to "authenticated";

grant references on table "public"."dialects" to "authenticated";

grant select on table "public"."dialects" to "authenticated";

grant trigger on table "public"."dialects" to "authenticated";

grant truncate on table "public"."dialects" to "authenticated";

grant update on table "public"."dialects" to "authenticated";

grant delete on table "public"."dialects" to "service_role";

grant insert on table "public"."dialects" to "service_role";

grant references on table "public"."dialects" to "service_role";

grant select on table "public"."dialects" to "service_role";

grant trigger on table "public"."dialects" to "service_role";

grant truncate on table "public"."dialects" to "service_role";

grant update on table "public"."dialects" to "service_role";

grant delete on table "public"."enrollments" to "anon";

grant insert on table "public"."enrollments" to "anon";

grant references on table "public"."enrollments" to "anon";

grant select on table "public"."enrollments" to "anon";

grant trigger on table "public"."enrollments" to "anon";

grant truncate on table "public"."enrollments" to "anon";

grant update on table "public"."enrollments" to "anon";

grant delete on table "public"."enrollments" to "authenticated";

grant insert on table "public"."enrollments" to "authenticated";

grant references on table "public"."enrollments" to "authenticated";

grant select on table "public"."enrollments" to "authenticated";

grant trigger on table "public"."enrollments" to "authenticated";

grant truncate on table "public"."enrollments" to "authenticated";

grant update on table "public"."enrollments" to "authenticated";

grant delete on table "public"."enrollments" to "service_role";

grant insert on table "public"."enrollments" to "service_role";

grant references on table "public"."enrollments" to "service_role";

grant select on table "public"."enrollments" to "service_role";

grant trigger on table "public"."enrollments" to "service_role";

grant truncate on table "public"."enrollments" to "service_role";

grant update on table "public"."enrollments" to "service_role";

grant delete on table "public"."federation_instances" to "anon";

grant insert on table "public"."federation_instances" to "anon";

grant references on table "public"."federation_instances" to "anon";

grant select on table "public"."federation_instances" to "anon";

grant trigger on table "public"."federation_instances" to "anon";

grant truncate on table "public"."federation_instances" to "anon";

grant update on table "public"."federation_instances" to "anon";

grant delete on table "public"."federation_instances" to "authenticated";

grant insert on table "public"."federation_instances" to "authenticated";

grant references on table "public"."federation_instances" to "authenticated";

grant select on table "public"."federation_instances" to "authenticated";

grant trigger on table "public"."federation_instances" to "authenticated";

grant truncate on table "public"."federation_instances" to "authenticated";

grant update on table "public"."federation_instances" to "authenticated";

grant delete on table "public"."federation_instances" to "service_role";

grant insert on table "public"."federation_instances" to "service_role";

grant references on table "public"."federation_instances" to "service_role";

grant select on table "public"."federation_instances" to "service_role";

grant trigger on table "public"."federation_instances" to "service_role";

grant truncate on table "public"."federation_instances" to "service_role";

grant update on table "public"."federation_instances" to "service_role";

grant delete on table "public"."flashcards" to "anon";

grant insert on table "public"."flashcards" to "anon";

grant references on table "public"."flashcards" to "anon";

grant select on table "public"."flashcards" to "anon";

grant trigger on table "public"."flashcards" to "anon";

grant truncate on table "public"."flashcards" to "anon";

grant update on table "public"."flashcards" to "anon";

grant delete on table "public"."flashcards" to "authenticated";

grant insert on table "public"."flashcards" to "authenticated";

grant references on table "public"."flashcards" to "authenticated";

grant select on table "public"."flashcards" to "authenticated";

grant trigger on table "public"."flashcards" to "authenticated";

grant truncate on table "public"."flashcards" to "authenticated";

grant update on table "public"."flashcards" to "authenticated";

grant delete on table "public"."flashcards" to "service_role";

grant insert on table "public"."flashcards" to "service_role";

grant references on table "public"."flashcards" to "service_role";

grant select on table "public"."flashcards" to "service_role";

grant trigger on table "public"."flashcards" to "service_role";

grant truncate on table "public"."flashcards" to "service_role";

grant update on table "public"."flashcards" to "service_role";

grant delete on table "public"."languages" to "anon";

grant insert on table "public"."languages" to "anon";

grant references on table "public"."languages" to "anon";

grant select on table "public"."languages" to "anon";

grant trigger on table "public"."languages" to "anon";

grant truncate on table "public"."languages" to "anon";

grant update on table "public"."languages" to "anon";

grant delete on table "public"."languages" to "authenticated";

grant insert on table "public"."languages" to "authenticated";

grant references on table "public"."languages" to "authenticated";

grant select on table "public"."languages" to "authenticated";

grant trigger on table "public"."languages" to "authenticated";

grant truncate on table "public"."languages" to "authenticated";

grant update on table "public"."languages" to "authenticated";

grant delete on table "public"."languages" to "service_role";

grant insert on table "public"."languages" to "service_role";

grant references on table "public"."languages" to "service_role";

grant select on table "public"."languages" to "service_role";

grant trigger on table "public"."languages" to "service_role";

grant truncate on table "public"."languages" to "service_role";

grant update on table "public"."languages" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."reading" to "anon";

grant insert on table "public"."reading" to "anon";

grant references on table "public"."reading" to "anon";

grant select on table "public"."reading" to "anon";

grant trigger on table "public"."reading" to "anon";

grant truncate on table "public"."reading" to "anon";

grant update on table "public"."reading" to "anon";

grant delete on table "public"."reading" to "authenticated";

grant insert on table "public"."reading" to "authenticated";

grant references on table "public"."reading" to "authenticated";

grant select on table "public"."reading" to "authenticated";

grant trigger on table "public"."reading" to "authenticated";

grant truncate on table "public"."reading" to "authenticated";

grant update on table "public"."reading" to "authenticated";

grant delete on table "public"."reading" to "service_role";

grant insert on table "public"."reading" to "service_role";

grant references on table "public"."reading" to "service_role";

grant select on table "public"."reading" to "service_role";

grant trigger on table "public"."reading" to "service_role";

grant truncate on table "public"."reading" to "service_role";

grant update on table "public"."reading" to "service_role";

grant delete on table "public"."sections" to "anon";

grant insert on table "public"."sections" to "anon";

grant references on table "public"."sections" to "anon";

grant select on table "public"."sections" to "anon";

grant trigger on table "public"."sections" to "anon";

grant truncate on table "public"."sections" to "anon";

grant update on table "public"."sections" to "anon";

grant delete on table "public"."sections" to "authenticated";

grant insert on table "public"."sections" to "authenticated";

grant references on table "public"."sections" to "authenticated";

grant select on table "public"."sections" to "authenticated";

grant trigger on table "public"."sections" to "authenticated";

grant truncate on table "public"."sections" to "authenticated";

grant update on table "public"."sections" to "authenticated";

grant delete on table "public"."sections" to "service_role";

grant insert on table "public"."sections" to "service_role";

grant references on table "public"."sections" to "service_role";

grant select on table "public"."sections" to "service_role";

grant trigger on table "public"."sections" to "service_role";

grant truncate on table "public"."sections" to "service_role";

grant update on table "public"."sections" to "service_role";

grant delete on table "public"."user_flashcard_progress" to "anon";

grant insert on table "public"."user_flashcard_progress" to "anon";

grant references on table "public"."user_flashcard_progress" to "anon";

grant select on table "public"."user_flashcard_progress" to "anon";

grant trigger on table "public"."user_flashcard_progress" to "anon";

grant truncate on table "public"."user_flashcard_progress" to "anon";

grant update on table "public"."user_flashcard_progress" to "anon";

grant delete on table "public"."user_flashcard_progress" to "authenticated";

grant insert on table "public"."user_flashcard_progress" to "authenticated";

grant references on table "public"."user_flashcard_progress" to "authenticated";

grant select on table "public"."user_flashcard_progress" to "authenticated";

grant trigger on table "public"."user_flashcard_progress" to "authenticated";

grant truncate on table "public"."user_flashcard_progress" to "authenticated";

grant update on table "public"."user_flashcard_progress" to "authenticated";

grant delete on table "public"."user_flashcard_progress" to "service_role";

grant insert on table "public"."user_flashcard_progress" to "service_role";

grant references on table "public"."user_flashcard_progress" to "service_role";

grant select on table "public"."user_flashcard_progress" to "service_role";

grant trigger on table "public"."user_flashcard_progress" to "service_role";

grant truncate on table "public"."user_flashcard_progress" to "service_role";

grant update on table "public"."user_flashcard_progress" to "service_role";

grant delete on table "public"."user_section_progress" to "anon";

grant insert on table "public"."user_section_progress" to "anon";

grant references on table "public"."user_section_progress" to "anon";

grant select on table "public"."user_section_progress" to "anon";

grant trigger on table "public"."user_section_progress" to "anon";

grant truncate on table "public"."user_section_progress" to "anon";

grant update on table "public"."user_section_progress" to "anon";

grant delete on table "public"."user_section_progress" to "authenticated";

grant insert on table "public"."user_section_progress" to "authenticated";

grant references on table "public"."user_section_progress" to "authenticated";

grant select on table "public"."user_section_progress" to "authenticated";

grant trigger on table "public"."user_section_progress" to "authenticated";

grant truncate on table "public"."user_section_progress" to "authenticated";

grant update on table "public"."user_section_progress" to "authenticated";

grant delete on table "public"."user_section_progress" to "service_role";

grant insert on table "public"."user_section_progress" to "service_role";

grant references on table "public"."user_section_progress" to "service_role";

grant select on table "public"."user_section_progress" to "service_role";

grant trigger on table "public"."user_section_progress" to "service_role";

grant truncate on table "public"."user_section_progress" to "service_role";

grant update on table "public"."user_section_progress" to "service_role";

create policy "Chapters of published courses are viewable by everyone"
on "public"."chapters"
as permissive
for select
to authenticated, anon
using ((EXISTS ( SELECT 1
   FROM courses
  WHERE ((courses.id = chapters.course_id) AND (courses.is_published = true)))));


create policy "Users can create chapters in own courses"
on "public"."chapters"
as permissive
for insert
to authenticated
with check ((EXISTS ( SELECT 1
   FROM courses
  WHERE ((courses.id = chapters.course_id) AND (courses.profile_id = auth.uid())))));


create policy "Users can delete chapters in own courses"
on "public"."chapters"
as permissive
for delete
to authenticated
using ((EXISTS ( SELECT 1
   FROM courses
  WHERE ((courses.id = chapters.course_id) AND (courses.profile_id = auth.uid())))));


create policy "Users can update chapters in own courses"
on "public"."chapters"
as permissive
for update
to authenticated
using ((EXISTS ( SELECT 1
   FROM courses
  WHERE ((courses.id = chapters.course_id) AND (courses.profile_id = auth.uid())))));


create policy "Users can view chapters of own courses"
on "public"."chapters"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM courses
  WHERE ((courses.id = chapters.course_id) AND (courses.profile_id = auth.uid())))));


create policy "chapters_delete_policy"
on "public"."chapters"
as permissive
for delete
to public
using ((EXISTS ( SELECT 1
   FROM courses c
  WHERE ((c.id = chapters.course_id) AND (c.profile_id = auth.uid())))));


create policy "chapters_insert_policy"
on "public"."chapters"
as permissive
for insert
to authenticated
with check ((EXISTS ( SELECT 1
   FROM courses
  WHERE ((courses.id = chapters.course_id) AND (courses.profile_id = auth.uid())))));


create policy "chapters_select_policy"
on "public"."chapters"
as permissive
for select
to public
using (true);


create policy "chapters_update_policy"
on "public"."chapters"
as permissive
for update
to public
using ((EXISTS ( SELECT 1
   FROM courses c
  WHERE ((c.id = chapters.course_id) AND (c.profile_id = auth.uid())))));


create policy "Published courses are viewable by everyone"
on "public"."courses"
as permissive
for select
to authenticated, anon
using ((is_published = true));


create policy "Users can create courses"
on "public"."courses"
as permissive
for insert
to authenticated
with check ((profile_id = auth.uid()));


create policy "Users can delete own courses"
on "public"."courses"
as permissive
for delete
to authenticated
using ((profile_id = auth.uid()));


create policy "Users can update own courses"
on "public"."courses"
as permissive
for update
to authenticated
using ((profile_id = auth.uid()))
with check ((profile_id = auth.uid()));


create policy "Users can view own courses"
on "public"."courses"
as permissive
for select
to authenticated
using ((profile_id = auth.uid()));


create policy "Admins can create dialects"
on "public"."dialects"
as permissive
for insert
to public
with check (((auth.role() = 'authenticated'::text) AND (EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((auth.uid() = users.id) AND ((users.role)::text = 'admin'::text))))));


create policy "Admins can delete dialects"
on "public"."dialects"
as permissive
for delete
to public
using (((auth.role() = 'authenticated'::text) AND (EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((auth.uid() = users.id) AND ((users.role)::text = 'admin'::text))))));


create policy "Admins can update dialects"
on "public"."dialects"
as permissive
for update
to public
using (((auth.role() = 'authenticated'::text) AND (EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((auth.uid() = users.id) AND ((users.role)::text = 'admin'::text))))))
with check (((auth.role() = 'authenticated'::text) AND (EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((auth.uid() = users.id) AND ((users.role)::text = 'admin'::text))))));


create policy "Anyone can read dialects"
on "public"."dialects"
as permissive
for select
to public
using (true);


create policy "Course creators can view enrollments in their courses"
on "public"."enrollments"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM courses
  WHERE ((courses.id = enrollments.course_id) AND (courses.profile_id = auth.uid())))));


create policy "Prevent users from updating enrollments"
on "public"."enrollments"
as permissive
for update
to public
using (false);


create policy "Service role has full access"
on "public"."enrollments"
as permissive
for all
to public
using ((auth.role() = 'service_role'::text));


create policy "Users can enroll themselves"
on "public"."enrollments"
as permissive
for insert
to public
with check ((auth.uid() = profile_id));


create policy "Users can unenroll themselves"
on "public"."enrollments"
as permissive
for delete
to public
using ((auth.uid() = profile_id));


create policy "Users can view their own enrollments"
on "public"."enrollments"
as permissive
for select
to public
using ((auth.uid() = profile_id));


create policy "Only admins can manage federation instances"
on "public"."federation_instances"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


create policy "Course owners can manage flashcards"
on "public"."flashcards"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM (chapters
     JOIN courses ON ((chapters.course_id = courses.id)))
  WHERE ((chapters.id = flashcards.chapter_id) AND (courses.profile_id = auth.uid())))));


create policy "Enrolled users can view flashcards"
on "public"."flashcards"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM ((chapters
     JOIN courses ON ((chapters.course_id = courses.id)))
     JOIN enrollments ON ((courses.id = enrollments.course_id)))
  WHERE ((chapters.id = flashcards.chapter_id) AND (enrollments.profile_id = auth.uid())))));


create policy "creators_can_manage_own_flashcards"
on "public"."flashcards"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM (chapters c
     JOIN courses co ON ((c.course_id = co.id)))
  WHERE ((c.id = flashcards.chapter_id) AND (co.profile_id = auth.uid())))));


create policy "students_can_read_enrolled_flashcards"
on "public"."flashcards"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM (chapters c
     JOIN enrollments e ON ((c.course_id = e.course_id)))
  WHERE ((c.id = flashcards.chapter_id) AND (e.profile_id = auth.uid())))));


create policy "Languages are viewable by everyone"
on "public"."languages"
as permissive
for select
to public
using (true);


create policy "Only admins can modify languages"
on "public"."languages"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'role'::text) = 'admin'::text))
with check (((auth.jwt() ->> 'role'::text) = 'admin'::text));


create policy "Allow insert for authenticated users"
on "public"."profiles"
as permissive
for insert
to public
with check ((auth.uid() = id));


create policy "Profiles are viewable by everyone"
on "public"."profiles"
as permissive
for select
to authenticated, anon
using (true);


create policy "Users can update own profile"
on "public"."profiles"
as permissive
for update
to authenticated
using ((auth.uid() = id))
with check ((auth.uid() = id));


create policy "Allow insert for authenticated users"
on "public"."reading"
as permissive
for insert
to public
with check ((auth.uid() IS NOT NULL));


create policy "Allow select for authenticated users"
on "public"."reading"
as permissive
for select
to public
using ((auth.uid() IS NOT NULL));


create policy "Course owners can manage reading content"
on "public"."reading"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM (chapters
     JOIN courses ON ((chapters.course_id = courses.id)))
  WHERE ((chapters.id = reading.chapter_id) AND (courses.profile_id = auth.uid())))));


create policy "Enrolled users can view reading content"
on "public"."reading"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM ((chapters
     JOIN courses ON ((chapters.course_id = courses.id)))
     JOIN enrollments ON ((courses.id = enrollments.course_id)))
  WHERE ((chapters.id = reading.chapter_id) AND (enrollments.profile_id = auth.uid())))));


create policy "Sections of published courses are viewable by everyone"
on "public"."sections"
as permissive
for select
to authenticated, anon
using ((EXISTS ( SELECT 1
   FROM (chapters
     JOIN courses ON ((courses.id = chapters.course_id)))
  WHERE ((chapters.id = sections.chapter_id) AND (courses.is_published = true)))));


create policy "Users can create sections in own courses"
on "public"."sections"
as permissive
for insert
to authenticated
with check ((EXISTS ( SELECT 1
   FROM (chapters
     JOIN courses ON ((courses.id = chapters.course_id)))
  WHERE ((chapters.id = sections.chapter_id) AND (courses.profile_id = auth.uid())))));


create policy "Users can delete sections in own courses"
on "public"."sections"
as permissive
for delete
to authenticated
using ((EXISTS ( SELECT 1
   FROM (chapters
     JOIN courses ON ((courses.id = chapters.course_id)))
  WHERE ((chapters.id = sections.chapter_id) AND (courses.profile_id = auth.uid())))));


create policy "Users can insert sections for their chapters"
on "public"."sections"
as permissive
for insert
to authenticated
with check ((EXISTS ( SELECT 1
   FROM (chapters c
     JOIN courses co ON ((c.course_id = co.id)))
  WHERE ((c.id = sections.chapter_id) AND (co.profile_id = auth.uid())))));


create policy "Users can update sections in own courses"
on "public"."sections"
as permissive
for update
to authenticated
using ((EXISTS ( SELECT 1
   FROM (chapters
     JOIN courses ON ((courses.id = chapters.course_id)))
  WHERE ((chapters.id = sections.chapter_id) AND (courses.profile_id = auth.uid())))));


create policy "Users can view sections of own courses"
on "public"."sections"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM (chapters
     JOIN courses ON ((courses.id = chapters.course_id)))
  WHERE ((chapters.id = sections.chapter_id) AND (courses.profile_id = auth.uid())))));


create policy "creators_can_view_course_progress"
on "public"."user_flashcard_progress"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM ((flashcards f
     JOIN chapters c ON ((f.chapter_id = c.id)))
     JOIN courses co ON ((c.course_id = co.id)))
  WHERE ((f.id = user_flashcard_progress.flashcard_id) AND (co.profile_id = auth.uid())))));


create policy "users_can_manage_own_progress"
on "public"."user_flashcard_progress"
as permissive
for all
to public
using ((profile_id = auth.uid()));


create policy "Users can delete their own section progress"
on "public"."user_section_progress"
as permissive
for delete
to public
using ((profile_id = auth.uid()));


create policy "Users can insert their own section progress"
on "public"."user_section_progress"
as permissive
for insert
to public
with check ((profile_id = auth.uid()));


create policy "Users can update their own section progress"
on "public"."user_section_progress"
as permissive
for update
to public
using ((profile_id = auth.uid()));


create policy "Users can view their own section progress"
on "public"."user_section_progress"
as permissive
for select
to public
using ((profile_id = auth.uid()));


CREATE TRIGGER set_chapter_serial_trigger BEFORE INSERT ON public.chapters FOR EACH ROW EXECUTE FUNCTION set_chapter_serial();

CREATE TRIGGER update_dialects_updated_at BEFORE UPDATE ON public.dialects FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_languages_updated_at BEFORE UPDATE ON public.languages FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER sync_profile_email_trigger BEFORE INSERT OR UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION sync_profile_email();
ALTER TABLE "public"."profiles" DISABLE TRIGGER "sync_profile_email_trigger";

CREATE TRIGGER set_section_serial_trigger BEFORE INSERT ON public.sections FOR EACH ROW EXECUTE FUNCTION set_section_serial();


